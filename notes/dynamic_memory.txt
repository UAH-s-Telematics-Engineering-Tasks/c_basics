Dynamic Memory
	We used to declare arrays with a fixed length at runtime but we can dinamically allocate their memory. Functions such as malloc(int n), let us store n bytes of memory with n being a variable that can change during execution. These dynamic structures are stored in the Heap Memory! It is separet from the stack where local variables are created with every function and with main, following the familiar LIFO order.
	Memory allocation fucntions return a pointer to the chunk of memory that fulfills our needs. 
	We should always free the memory we are not gonna need anymore. free(pointer to allocated memory) frees the chunk of memory whose first element is at (pointer to allocated memory).
	Malloc() returns a void pointer, it is not referred to any specific data type. That is why we should always cast the pointer to the desired daat type, in order to implement a good practice programing.
	Realloc() let's us increse or decrease a chunk of allocated memory. It gets a pointer to te chunk of memory and the new desired size. It will return a pointer to the new block of NULL if the operation was not feasible. If we want to create a dynamic chunk of memory with realloc() we need to pass a NULL pointer as an argument or it will otherwise get confused. 
	As realloc() only affects a single pointer, we only have to free() it at the end, not during execution, or we will otherwise lose our data!
With realloc() we should use an auxiliary pointer because if it doesn't work we will overwrite the pointer we had before with NULL!! Realloc() copies everything we had in the original block in case it has to find another block of memory with a different address than our origial block. If it does so, it will also free its memory. If this is our case, we will have to update the pointer of our array to the location given by realloc(). This would be, in code: if (p_aux != p_original) {p_original = p_aux;}; 
	If we work with an array of structs with an element of the struct beeing a pointer, and we dynamically assign memory to that pointer, we have to recursively free each pointer from each struct with a for caluse.
